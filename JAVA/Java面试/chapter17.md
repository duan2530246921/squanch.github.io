# MySql
## 164.数据库的三范式是什么？
---
什么是范式？

简言之就是，数据库设计对数据的存储性能，还有开发人员对数据的操作都有莫大的关系。所以建立科学的，规范的的数据库是需要满足一些规范的来优化数据数据存储方式。在关系型数据库中这些规范就可以称为范式。

什么是三大范式？

第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。 第二范式（2NF）：首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依 赖于主键，而不能只依赖于主键的一部分。 第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖 于非主键列 B，非主键列 B 依赖于主键的情况。注：关系实质上是一张二维表，其中每一行是一个元组，每一列是一个属性

## 165.一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？
---
- 数据库引擎如果是 MyISAM ，那 id 就是 8。
- 数据库引擎如果是 InnoDB，那 id 就是 6。
InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失

## 166.如何获取当前数据库版本？
---
第一种方法：打开mysql在命令提示符上输入  select version();

第二种方法：在cmd里面输入 mysql -V 来获取mysql版本号

## 167.说一下 ACID 是什么？
---
ACID 一般是指数据库事务的ACID

一个事务一般是指多个操作的集合，比如插入数据库分两段插入，第二次插入错误，第一次插入操作也需要回退

ACID的翻译

1. Atomicity 原子性

2. Consistency 一致性

3. Isolation 隔离性

4. Durability 耐久性

原子性，指的是整个事务是一个独立的单元，要么操作成功，要么操作不成功

一致性，事务必须要保持和系统处于一致的状态（如果不一致会导致系统其它的方出现bug）

隔离性，事务是并发控制机制，他们的交错也需要一致性，隔离隐藏，一般通过悲观或者乐观锁实现

耐久性，一个成功的事务将永久性地改变系统的状态，所以在它结束之前，所有导致状态的变化都记录在一个持久的事务日志中

## 168.char 和 varchar 的区别是什么？
---
1. char类型的长度是固定的，varchar的长度是可变的。

   这就表示，存储字符串'abc'，使用char(10)，表示存储的字符将占10个字节（包括7个空字符）

   使用varchar2(10),，则表示只占3个字节，10是最大值，当存储的字符小于10时，按照实际的长度存储。

2. char类型的效率比varchar的效率稍高

3. varchar 与 varchar2的区别

varchar2是oracle开发的一个数据类型。

工业标准的varchar可以存储空字符串，oracle的varchar2还可以存储NULL值，如果想要有向后兼容的能力建议使用varchar2

4. varchar2比char节省空间，但是在效率上比char稍差些。既要获得效率即必须牺牲一点空间，这就是设计上的"以空间换时间"

varchar2虽然比char节省空间，但是一个varchar2列经常被修改，而且每次修改的数据长度不同，这会引起“行迁移的现象”，

而这造成的多余的I/O，是数据库设计中尽量避免的，在这种情况下使用char代替varchar2会更好些。

总结：
1. 如果一个字段经常被修改，而且每次修改的数据长度不同，为了效率应当考虑用char定长代替varchar2变长。（列如一个用户的名字经常被修改）
2. 设计的时候尽量考虑  用空间换时间。

## 169.float 和 double 的区别是什么？
---
1.在内存中占有的字节数不同

　　　　单精度浮点数在机内存占4个字节

　　　　双精度浮点数在机内存占8个字节

2. 有效数字位数不同

　　　　单精度浮点数有效数字8位

　　　　双精度浮点数有效数字16位

3. 数值取值范围

　　　　单精度浮点数的表示范围：-3.40E+38~3.40E+38

　　　　双精度浮点数的表示范围：-1.79E+308~-1.79E+308

4. 在程序中处理速度不同

　　　　一般来说，CPU处理单精度浮点数的速度比处理双精度浮点数快

- 注意：float是8位有效数字，第7位数字将会四舍五入

面试题：
1. java中3*0.1==0.3将会返回什么？true还是false？

　 fale,因为浮点数不能完全精确的表示出来，一般会损失精度。

2. java中float f = 3.4;是否正确？

　 不正确，3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于向下转型会造　　成精度损失，因此需要强制类型转换float f = (float)3.4;或者写成 float f = 3.4f;才可以。

## 170.mysql 的内连接、左连接、右连接有什么区别？
---
1. 内连接,显示两个表中有联系的所有数据;

2. 左链接,以左表为参照,显示所有数据,右表中没有则以null显示

3. 右链接,以右表为参照显示数据，,左表中没有则以null显示

## 171.mysql 索引是怎么实现的？
---
1. 添加PRIMARY KEY（主键索袭引百）
```mysql>ALTER TABLE `度table_name` ADD PRIMARY KEY ( `column` )```
2. 添加UNIQUE(唯一索引问)
```mysql>ALTER TABLE `table_name` ADD UNIQUE ( `column` )```
3. 添加INDEX(普通索引)
```mysql>ALTER TABLE `table_name` ADD INDEX index_name ( `column` )```
4. 添加FULLTEXT(全文索答引)
```mysql>ALTER TABLE `table_name` ADD FULLTEXT ( `column`)```
5. 添加多列索引
```mysql>ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )``` 

## 172.怎么验证 mysql 的索引是否满足需求？
---
使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。 explain 语法：explain select * from table where type=1。

## 173.说一下数据库的事务隔离？
---
说事务隔离级别之前，先看看如下问题：

1. 脏读（Dirty Read）

所谓脏读是指一个事务中访问到了另外一个事务未提交的数据。如A事务对一条数据进行了修改，但是事务还没提交，此时B事务读到了A事务修改了但是未提交的数据，这就是脏读。

2. 不可重复读（Non-repeatable read）

是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不 可重复读。

3. 幻读(Phantom Read)

所谓幻读是指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。比如同一个事务A内第一次查询时候有n条记录，但是第二次同等条件下查询却又n+1条记录，这就好像产生了幻觉，为啥两次结果不一样那。其实和不可重复读一样，发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据。不同在于不可重复读是同一个记录的数据内容被修改了，幻读是数据行记录变多了或者少了

了解了如上几个问题之后，我们再来看看四种事务隔离级别。

1. Read Uncommitted（读取未提交内容）

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读。

2. Read Committed（读取提交内容）

这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这就是所谓的不可重复读（Non-repeatable read）。

3. Repeatable Read（可重读）

这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

4. Serializable（串行化）

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

## 174.说一下 mysql 常用的引擎？
---
1. InnoDB

InnoDB 的存储文件有两个，后缀名分别是 .frm 和 .idb，其中 .frm 是表的定义文件，而 idb 是数据文件。

InnoDB 中存在表锁和行锁，不过行锁是在命中索引的情况下才会起作用。

InnoDB 支持事务，且支持四种隔离级别（读未提交、读已提交、可重复读、串行化），默认的为可重复读；而在 Oracle 数据库中，只支持串行化级别和读已提交这两种级别，其中默认的为读已提交级别。

2. Myisam

Myisam 的存储文件有三个，后缀名分别是 .frm、.MYD、MYI，其中 .frm 是表的定义文件，.MYD 是数据文件，.MYI 是索引文件。

Myisam 只支持表锁，且不支持事务。Myisam 由于有单独的索引文件，在读取数据方面的性能很高 。

3. 存储结构

InnoDB 和 Myisam 都是用 B+Tree 来存储数据的

## 175.说一下 mysql 的行锁和表锁？
---
    对于ＭyISAM的表锁，主要有以下几点
1. 共享读锁（S）之间是兼容的，但共享读锁（S）和排他写锁（X）之间，以及排他写锁之间（X）是互斥的，也就是说读和写是串行的。
2. 在一定条件下，ＭyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表和插入的锁争用问题。
3. ＭyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIPORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。
4. 由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，ＭyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。
 
    对于InnoDB表，主要有以下几点
1. InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。
2. InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。
3. 在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。
4. ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。
5. 锁冲突甚至死锁很难完全避免。

    在了解InnoDB的锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：
   
- 尽量使用较低的隔离级别
- 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会。
- 选择合理的事务大小，小事务发生锁冲突的几率也更小。
- 给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。
- 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大减少死锁的机会。
- 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。
- 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁。
- 对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能

## 176.说一下乐观锁和悲观锁？
---
> 乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。

- 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

- 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
两种锁的使用场景

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

## 177.mysql 问题排查都有哪些手段？
---
- 使用 show processlist 命令查看当前所有连接信息。
- 使用 explain 命令查询 SQL 语句执行计划。
- 开启慢查询日志，查看慢查询的 SQL。

## 178.如何做 mysql 的性能优化？
---
- 为搜索字段创建索引。
- 避免使用 select *，列出需要查询的字段。
- 垂直分割分表。
- 选择正确的存储引擎。
