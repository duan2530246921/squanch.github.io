# JVM
## 194.说一下 jvm 的主要组成部分？及其作用？
---
1. 堆。 堆是Java对象的存储区域，任何用new字段分配的Java对象实例和数组，都被分配在堆上，Java堆可使用-Xms -Xmx进行内存控制，值得一提的是从JDK1.7版本之后，运行时常量池从方法区移到了堆上。
2. 方法区。它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，方法区在JDK1.7版本及以前被称为永久代，从JDK1.8永久代被移除。
3. 虚拟机栈。虚拟机栈中执行每个方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
4. 本地方法栈。与虚拟机栈发挥的作用相似，相比于虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的Native方法服务，执行每个本地方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
5. 程序计数器。指示Java虚拟机下一条需要执行的字节码指令。

以上五个区域是Java虚拟机内存划分情况，其中方法区和堆被JVM中多个线程共享，比如类的静态常量就被存放在方法区，供类对象之间共享，虚拟机栈，本地方法栈，pc寄存器是每个线程独立拥有的，不会与其他线程共享。
所以Java在通过new创建一个类对象实例的时候，一方面会在虚拟机栈中创建一个该对象的引用，另一方面会在堆上创建类对象的实例，然后将对象引用指向该对象的实例。对象引用存放在每一个方法对应的栈帧中。

## 195.说一下 jvm 运行时数据区？
---
- 程序计数器
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区

## 196.说一下堆栈的区别？
---
堆栈与堆区别为：空间不同、地址方向不同、释放不同。

一、空百间不同

1、堆栈：堆栈是自动分配变量，以及函数调用的时候所使度用的一些空间。

2、堆：堆是是由malloc之类函数分配的空间所在地。

二、地址方向不同

1、堆栈：堆栈的地知址方向是由高向低减少性扩展，有总道长度大小限制。 

2、堆：堆的地址方向是由低向高增长性扩展，没有总长度大小限制。 

三、释放不同

1、堆栈：回堆栈由编译器自动释放，存放函数的参数值，局部变量的值等。

2、堆：堆由程序员答人工进行释放， 若程序员不释放，程序结束时可能由OS回收 。

## 197.队列和栈是什么？有什么区别？
---
1. 操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。

2. 可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。

3. 操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。

## 198.什么是双亲委派模型？
---
简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载Java类型。

类的加载机制
通常类加载机制有三个基本特征：

- 双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。 例如，Java 中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。
- 可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的，不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。
- 单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。

## 199.说一下类加载的执行过程？
---


前言一个Java文件从编码完成到最终执行，一般主要包括两个过程

编译

运行

编译，即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。

运行，则是把编译声称的.class文件交给Java虚拟机(JVM)执行。

而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。

举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。

由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。

类加载
类加载的过程主要分为三个部分：

加载

链接

初始化

而链接又可以细分为三个小部分：

验证

准备

解析

 

加载

简单来说，加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。

这里有两个重点：

字节码来源。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译

类加载器。一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器。

注：为什么会有自定义类加载器？

一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。

另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。

验证
主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。

包括对于文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？

对于元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？

对于字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。

对于符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？

准备
主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值。

特别需要注意，初值，不是代码中具体写的初始化的值，而是Java虚拟机根据不同变量类型的默认初始值。

比如8种基本类型的初值，默认为0；引用类型的初值则为null；常量的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456

解析
将常量池内的符号引用替换为直接引用的过程。

两个重点：

符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。

直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量

举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。

在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。

初始化
这个阶段主要是对类变量初始化，是执行类构造器的过程。

换句话说，只对static修饰的变量或语句进行初始化。

如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。

如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。

## 200.怎么判断对象是否可以被回收？
---
一、引用计数算法：
　　判断对象的引用数量：

　　　　通过判断对象的引用数量来决定对象是否可以被回收；

　　　　每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1；

　　　　任何引用计数为0的对象实例可以被当作垃圾收集；
　　优缺点：

　　　　优点：执行效率高，程序执行受影响较小；

　　　　缺点：无法检测出循环引用的情况，导致内存泄漏；
二、可达性分析算法：

　　通过判断对象的引用链是否可达来决定对象是否可以被回收；
　　可以作为GC Root的对象有：

　　　　虚拟机栈中引用的对象（栈帧中的本地变量表）；

　　　　方法区中的常量引用对象；

　　　　方法区中类静态属性引用对象；

　　　　本地方法栈中JNI（Native方法）的引用对象；

　　　　活跃线程中的引用对象；

## 201.java 中都有哪些引用类型？
---
强引用（strongreference）就是指在程序代码之中普遍存在的,类似“Object obj=new Object()” 这类的引用,只要强引用还存在,垃圾收集器永远不会回收掉被引用的对象实例。

软引用（softreference）是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象, 在系统将要发生内存溢出异常之前,将会把这些对象实例列进回收范围之中进行 第二次回收。如果这次回收还没有足够的内存,才会抛出内存溢出异常。在 JDK 1.2 之后,提供了 SoftReference 类来实现软引用。

弱引用（weakreference）也是用来描述非必需对象的,但是它的强度比软引用更弱一些,被弱 引用关联的对象实例只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时, 无论当前内存是否足够,都会回收掉只被弱引用关联的对象实例。在 JDK 1.2 之 后,提供了 WeakReference 类来实现弱引用。

虚引用（phantomreference）也称为幽灵引用或者幻影引用,它是最弱的一种引用关系。一个对象 实例是否有虚引用的存在,完全不会对其生存时间构成影响,也无法通过虚引用 来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象 实例被收集器回收时收到一个系统通知。在 JDK 1.2 之后,提供了 PhantomReference 类来实现虚引用。
## 202.说一下 jvm 有哪些垃圾回收算法？
---
常用的垃圾回收算法有如下四种：标记-清除、复制、标记-整理和分代收集。

标记-清除算法
从算法的名称上可以看出，这个算法分为两部分，标记和清除。首先标记出所有需要被回收的对象，然后在标记完成后统一回收掉所有被标记的对象。

这个算法简单，但是有两个缺点：一是标记和清除的效率不是很高；二是标记和清除后会产生很多的内存碎片，导致可用的内存空间不连续，当分配大对象的时候，没有足够的空间时不得不提前触发一次垃圾回收。

复制算法
这个算法将可用的内存空间分为大小相等的两块，每次只是用其中的一块，当这一块被用完的时候，就将还存活的对象复制到另一块中，然后把原已使用过的那一块内存空间一次回收掉。这个算法常用于新生代的垃圾回收。

复制算法解决了标记-清除算法的效率问题，以空间换时间，但是当存活对象非常多的时候，复制操作效率将会变低，而且每次只能使用一半的内存空间，利用率不高。

标记-整理算法
这个算法分为三部分：一是标记出所有需要被回收的对象；二是把所有存活的对象都向一端移动；三是把所有存活对象边界以外的内存空间都回收掉。

标记-整理算法解决了复制算法多复制效率低、空间利用率低的问题，同时也解决了内存碎片的问题。

分代收集算法
根据对象生存周期的不同将内存空间划分为不同的块，然后对不同的块使用不同的回收算法。一般把Java堆分为新生代和老年代，新生代中对象的存活周期短，只有少量存活的对象，所以可以使用复制算法，而老年代中对象存活时间长，而且对象比较多，所以可以采用标记-清除和标记-整理算法。 

## 203.说一下 jvm 有哪些垃圾回收器？
---
新生代收集器：

Serial
ParNew
Parallel Scavenge


老年代收集器：

Serial Old
CMS
Parallel Old


堆内存垃圾收集器：

G1

## 204.详细介绍一下 CMS 垃圾回收器？
---
垃圾回收器从线程运行情况分类有三种

- 串行回收，Serial回收器，单线程回收，全程stw；
- 并行回收，名称以Parallel开头的回收器，多线程回收，全程stw；
- 并发回收，cms与G1，多线程分阶段回收，只有某阶段会stw；

CMS垃圾回收特点

- cms只会回收老年代和永久带（1.8开始为元数据区，需要设置CMSClassUnloadingEnabled），不会收集年轻带；
- cms是一种预处理垃圾回收器，它不能等到old内存用尽时回收，需要在内存用尽前，完成回收操作，否则会导致并发回收失败；所以cms垃圾回收器开始执行回收操作，有一个触发阈值，默认是老年代或永久带达到92%；

## 205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？
---


新生代回收器：Serial、ParNew、Parallel Scavenge

老年代回收器：Serial Old、Parallel Old、CMS

整堆回收器：G1

新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。

## 206.简述分代垃圾回收器是怎么工作的？
---


分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。 新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，

它的执行流程如下：

把 Eden + From Survivor 存活的对象放入 To Survivor 区；

清空 Eden 和 From Survivor 分区； From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。

每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。

老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。

以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。

## 207.说一下 jvm 调优的工具？
---
Jconsole : jdk自带，功能简单，但是可以在系统有一定负荷的情况下使用。对垃圾回收算法有很详细的跟踪。

JProfiler：商业软件，需要付费。功能强大。

VisualVM：JDK自带，功能强大，与JProfiler类似。推荐。

## 208.常用的 jvm 调优的参数都有哪些？
---
1. -Xms

    s为strating，表示堆内存起始大小

2. -Xmx

    x为max，表示最大的堆内存

（一般来说-Xms和-Xmx的设置为相同大小，因为当heap自动扩容时，会发生内存抖动，影响程序的稳定性）

3. -Xmn

    n为new，表示新生代大小

（-Xss：规定了每个线程虚拟机栈（堆栈）的大小）

4. -XX:SurvivorRator=8 

    表示堆内存中新生代、老年代和永久代的比为8:1:1

5. -XX:PretenureSizeThreshold=3145728

    表示当创建（new）的对象大于3M的时候直接进入老年代

6. -XX:MaxTenuringThreshold=15    

    表示当对象的存活的年龄（minor gc一次加1）大于多少时，进入老年代

7. -XX:-DisableExplicirGC

    表示是否（+表示是，-表示否）打开GC日志